では、今日の極めて重要なサーバーサービスについてはどうでしょうか。私たちは、クラウドの利用をよりシンプルにするというアイデアを常に持っており、サーバーレスアプローチは常に最良の方法であるとしてきました。何がサーバーレスで、何が本当のサーバーレスでないかを定義しようとすると、何もかもがサービスになるように思えますが、実はサービスかどうかではなく、WiFiやワイヤレスのように、ワイヤのことを考えずにWiFiを使っていても、ワイヤにはとんでもない数のワイヤがあり、それらは裏側にあるだけで、そのことについて考えなければならないのです。ですから、私はむしろサービスを、サービスや実現技術ではなく、ビジネス価値に焦点を当てたアプリケーション構築の考え方やアプローチと考え、アプリをプロトタイピングから本番稼動までより速く、速いフィードバックループで、ビジネスの前に素早く反復できるようにする利点があると考えています。これは、最新のアプリケーションを最小の総所有コストで構築・運用するための最良の方法です。しかし、その考え方は、アプリを作ればいいというものではありません。つまり、サービスを運用モデルとして考え、運用タスクを引き受けることを明確に避け、未分化のシステム管理タスクをアウトソースしようとし、サービス以外のすべてのコンポーネントを、将来のメンテナンスを最適化するために今正しい選択をするための追加責任として考えてはどうでしょうか？また、保守派がノーオペを作らないと思わないでください。それは確かに逆で、違うのです。あなたはAWSのようなプラットフォーム・プロバイダーのある種をオフロードすることで、小規模なビジネスに集中することができます。開発者OPSやプラットフォーム・チームを増強するためのプラットフォームとなるのです。これにより、クラウド上で構築し、セキュリティの俊敏性と拡張性を活用することができます。データやイベントの流れに集中できるのです。このアプローチでは、イベント駆動型アーキテクチャを使用して、イベントのストリームを生成、消費、反応することに重点を置いて、イベント構築アプリケーションを構築することになります。このようなサービスは、疎結合で分散しており、どのような規模でも非常に柔軟です。しかし、トレードオフがないとは言い切れません。優れたアーキテクトは、常にトレードオフを考える必要があるのです。より多く動くものを使って構築するのは、これまでとは異なる方法です。開発・運用のやり方が異なる中で、データがどのように移動し、どのように保持されるのかを理解する必要があります。また、クラウドをこれまで以上に活用することも必要でしょう。リバティミューチュアルのような企業は、他の多くの企業と同様に、サービスマインドセットをサービスの利点のすべてと見なして、これを実践しています。彼らは戦略的かつ生産的なサービスファースト戦略をとることで、アジリティを向上させ、コストを削減することができるのです。サービス以外の選択肢の方がより良い製品になるのであれば、私はそちらを選びます。その場合、私は正当な理由があれば、そちらを選択します。私はリバティミューチュアル社のことだけを言っているのではありません。なぜなら、私は実際にマット・クルター氏やカースティ・プロ氏など、アイデンティティを働かせる人たちを希望しているからです。彼らは、ビルダーのために精選された経験を構築するために懸命に働いています。彼らは、障害物、有効な制約、技術チーム、正しいことをしているという確信を与えるための高速フィードバックループを備えたプラットフォームと見なしています。そして、彼らが道を踏み外したとき、早期に是正するためのフィードバックがここにあります。サーバーレスによって、ビルダーがデプロイメントやインフラストラクチャのコードを所有することがより簡単になり、舗装された道を構築することが多くなりました。ここでは、クラウドへの旅であなたを導くために成文化されたいくつかのコモディティグッドプラクティスです良いクラウドソリューションとサービスは、制約を移動し、意思決定プロセスをスピードアップし、必要なトップダウンアプローチの開発と保守を可能にするよく意味包括中央プラットフォームやセキュリティチームは、開発サイクルの後半に物事をブロック、これはイライラしています。チームは、それが彼らのない技術革新を入れているように感じています。より成功するために サービス・アプローチを採用することで、セキュリティのようなものに対する見方を変え、開発チームがセキュリティに対応できるようにする必要があります。むしろ、定義や革新から人質に取られたように感じることもあります。製品としてのプラットフォームは、開発者の体験を向上させ、より良いビジネス成果を提供するために考えるべきものです。これは、CI CDパイプラインによるアジリティの加速、アカウンタビリティ・プロセスの自動化、サードパーティ・システムとの接続管理などに注力するチームやCTOが、堅牢なガードレールやプロセスの自動化によって悪行の半径を小さくすることに取り組むことを意味しています。そして、SCPや許可境界を定義するコントロール・タワーのようなサービスを上手に利用する準備が整っています。CFN lintやCFN、NAGなど、あらゆる種類のガバナンス・ツールを使いこなすことができるのです。ビルダーが正しいことを行っているかどうかを確認するためのセーフガードを感じますか？それは、例えば、ネットワーク接続やセントラルヒート病も報告するチームを意味します。そして、このツールは共有可能で拡張性があることが重要です。CDKコンストラクトと呼ばれるCDKやサービスパターンをビルディングブロックとして使用することで、他のチームがプロジェクトを共同して進められるようにし、建設業者がより速く、より安全に作業できるような道筋を提供するのです。そして、どのようなアプローチでゲイを成文化するのか、アメリカでは、よく設計されたフレームワークの上で、リーンとして機能することができるのです。そしてこれは正確なベストプラクティスであり、実際にブログの記事シリーズで、アーキテクトフレームワークに関するすべての質問を掘り下げ、私たちが信じて特定のステップを実行するときにそれらがどのように適用されるかを行っています。それは、私が彼を愛したときのような音のセットではありません。そして彼は言う、幸運を考えるとき、それはあなたの心を変える価値があるかもしれないと、彼が精神衛生と呼ぶものを意識するように。そして、これらは2つの方法で彼に幸運をもたらすとされています。変更にかかるコストの削減と、変更しなければならない可能性の削減です。パターンと自動化を定義した、よくアーキテクトされたサービス・アプリケーションを信じれば、変更を加えるスピードを上げることができる。また、デリバリーのスピードやベロシティを上げれば、意思決定を迅速に変更することができ、ロックのいくつかを軽減することができます。確かに、考える価値のあることで、もっと詳しく、もっと素晴らしい自由を手に入れるために、必ず見ておくべきことです。私たちは実際にモンスター・チャットを作り、この素晴らしい本を書きました。実は今日発売なんです。バッテリーフライホイール効果、パワーフューチャー、モダンなクラウドへのあなたの組織を加速させるという本です。この本を読めば、サーバーレスを大規模に行うための適応力のある組織をどのように作ることができるかを理解することができます。だから、サービスが何をしているか、何をしていないかではなく、ビジネス価値にフォーカスしたマインドセットのサービスを考えよう。上辺だけでなく町の中に構築することで長期的な運用を最適化し、データの流れに集中してイベント駆動型のアプリケーションを構築し、プラットフォームチームに権限を与えて、よく設計された動きでビジネスの残りの部分に干渉し、サービスファーストを心がけましょう。さて、イベント駆動型のサービス・アプリケーションを構築できるようになると、それはイベント駆動型アプリケーションと呼ばれるようになり、つまり、イベントが動き回り、状態について話す価値があります。サービスを構築し、アプリケーションになるにつれ、ステートは本当に重要です。同期的なワークロードに頼らずに。まず、アプリケーションの一部を接続するために、レイテンシーと多くの障害モードに悩まされることになり、リカバリーが複雑になります。そこで、疎結合のシステムでレイテンシーを減らし、より回復力を高めるために、非同期のパターンに注目したい。また、非同期は常にAPIの後ろにいる必要はありません。AWSには、アプリケーションコンポーネントが非同期通信を処理するために使用できる、非常に強力なメッセージングシステムとサービスが多数あります。SQSキュー、SNSトピック、Event Busルーティング、Kinesisストリーミングなどです。しかし、そのうちの1つを掘り下げると、「Call of Enbridge」にはベテラン向けの特別なサービスがあります。このサービスでは、多くのソースからイベントを受け取ることができ、それらはAWSサービス、カスタムアプリケーション、またはMongoDBデータドッグOctaやSalesforceなどの多くのSaaSアプリケーションプロバイダとすることができます。これらのイベントは、イベントブリッジ内の様々なインベーダーに流れ込みます。そして、これらのイベントを任意の数のターゲットに導くための洗練されたルールを書くことができます。これらは他のAWSサービスであったり、他のバスであったりする。実際、インターネット上のどのようなAPIでも、これによって様々な統合パターンを作ることができます。この核となるのはイベントを考えることで、それは同僚のDavidが指摘するように、サービスアプリケーションの言語であり、それを通じて、ある種のメッセージングサービスを間に挟んでコンポーネントを分離したまま分散システムを作ることができるアーキテクチャに流れ込むのです。メッセージング・サービスを間に挟むことで、コンポーネントを分離したまま、分散システムを構築することができます。さらに、作成したイベントを使って簡単に追加することができ、柔軟で進化的なアーキテクチャを実現できます。イベントにどんな情報を盛り込もうかと、誰もが常に考えています。そこで、情報を増やしすぎずに、イベントを充実させ、役に立つ情報を提供するためのアイデアを紹介します。

イベントと詳細があります。データの詳細フィールドを構造化するために、もう少し詳細を見て今操作します。イベントが属するサービス環境やドメインに関するより良いデータを追加し、境界を越えて一緒にイベントの流れを追跡するのに役立ちます。あるいは、相関IDも考えられる。これもアイテムの効力トークンとして使われ、トレースの役に立つ。次に、詳細なデータ自体の中で、イベント情報を取得し、それをデータビューで使用することができます。下流の消費者サービスは、これをさらに処理する際に利用することができます。しかし、今、私たちはいくつかのカップリングを作っています。理想的には、プロデューサがこの例では常に、下流のサービスが注文やユーザーに関する配信の詳細をサービスするためにコールバックする必要がなく、引き込み式の密結合アーキテクチャを防止する、完全に非結合型システムを持つ必要があります。現実には、どのようなデータが他の場所で必要とされているかによって、どのようなイベントコンテンツを送信するかを考える必要があります。そして、どのサービスがそのイベントに対応するのか、また、アプリケーションとの境界のコンテキストをどのように定義するのかを考える必要があります。そして、この結合を避けるために、おそらく下流の消費者が必要と考える情報をデータフィールドに追加することになるでしょう。もちろん、これを行うには、物事を追跡するためのバージョンスキーマが必要になるかもしれません。以下は、イベントに注文とユーザーの詳細を追加する例です。そして、これはイベント・キャリード・ステート・トランスファーという便利な技術で、イベントの状態がサービスを通じて流れ、下流のサービスは、データが必要とするローカルなビューやキャッシュを構築し、それを補強したり充実させて、別のサービスに送信することができます。イベント・キャリード・ステート・トランスファーを使用すると、分散状態の問題に巻き込まれることなく、必要なデータに対処するために十分な一時的なローカルデータとのデカップリングを実現できるため、非常に強力です。そしてもちろん、コンシューマは時間が経てばやってくるので、作成したイベントでアクティベートすることができます。また、意図せずして実装の詳細が公開されることもあります。トレーダーが監査の詳細を伝えると、十分な情報やコンテキストがない可能性があります。そして、あなたはこの試験で知っている、正確に時間の量は、アドレスが下流のサービスが動作するのに十分な情報を持っているのでしょうか？私は、下流のサービスには見せたくないようなPII情報を作成することにしています。そして、アプリケーションの周りのイベントを行う際に、これらのことを考慮する価値があることは確かです。イベントの状態について考えるとき、イベントをメッセージング・サービスの非同期呼び出しを使用するサービス・アプリケーションの言語として考えてみてください。イベントをコンテンツとメタデータで充実させ、他のサービスにとってより有用なものにしましょう。そして、トレードオフを考慮しながら、イベントを利用した状態遷移をうまく切り離すことも考えてください。そこで次に取り上げるのは、COVIDではなくコンフィギュレーションを使用し、可能な限りマネージドサービスと機能を使用したサービス化可能なサービスというトピックです。サービスアプリケーションについて話すとき、一般的にはラムダを使うことが多いのですが、ラムダは様々な言語で書くことができますし、自分で書くこともできます。イベントソースがあり、変更やリクエストに基づいてラムダ関数をトリガーし、イベントに対して何らかのアクションを実行し、それを別のサービスに送ります。そして、これは非常に一般的なラムダベースのサービスアプリケーションです。しかし、このラムダ関数を削除し、イベントソースや他のサービスが直接他の宛先のサービスと対話できるようにすれば、独自のコードを保守する必要がなくなるとしたらどうでしょうか。これは、サービス・フルと呼ばれる直接サービス統合です。lambdaの創始者であるJane Eyreの名言がありますが、これは8年後に盗むための一般的な努力です。もうひとつ考えるべきことは、コードにどれだけのロジックを詰め込んでいるかということです。ラムダ関数にどんどん機能を追加して、コード内のすべての処理を行わせていませんか？決定木がない場合は、ラムダ関数と呼ばれるものになり、かなり大きくなってしまうので、別の方法を考えましょう。ラムダ関数で実際に呼び出しているロジックがどれだけ少ないかというと、ラムダ関数の中に大したことをやっていないコードが大量にあるのです。複雑なコードを追加している上に、ほとんどのテストが安全でなく、使っていない。そして、このようなことはしばしば、本当に善意から始まるのです。クラウドに移行する場合、例えばオンプレミスで、アプリの多くのコンポーネントと機能を一箇所に集めたコンテナを持っているとします。そして、クラウドに移行して、コンピュータでラップを賢く選択し、おそらくAPIを前に貼り付けて、これらのコンポーネントと複雑さをすべてある種のストレージを使用しています。ラムダ関数に移行すればいいのです。最終的には、これらのコンポーネントを、その仕事に適した基本的なサービスを用いて、個別のサービスに移行する必要があります。フロントエンドをS3に移行し、APIゲートウェイで認証を処理する。あるいはキャッシュや略奪、再構築など。メッセージング・サービスは、トランザクションをワークフローにオフロードすることで非同期に処理し、ネイティブ・サービスのエラー・ハンドリングやリトライを使用します。このように、アプリケーションをスケールアウトさせることで、より高い耐障害性とセキュリティの向上、そしてコストの削減を実現することができます。また、サービスアプリケーションの課題の1つは、すでにコードにある複雑さを取り除き、設定によって管理できるサービスとして見ることができるようになれば、管理しなければならないことが増えるということです。もう1つ考えるべきことは、独自のコードを書くのではなく、サービスアプリの通信モデルとしてオーケストレーションやコレオグラフィーをいかに効果的に利用するかということです。そして、左側のコンフィギュレーションとオーケストレーションは、中央のサービスを使って、サービスが使われる際の相互作用や順序を調整することで、より厳密に管理できるようになります。コレオグラフィーは、中央の調整なしに、サービス間の制御とイベントの流れで通信します。もちろん、さまざまなユースケースでコレオグラフィーとオーケストレーションの両方を使用するアプリケーションも多くあります。そしてステップ関数は、トランザクションのためのワークフローサービスとして、ビジュアルワークロードを使った分散アプリのコンポーネントを調整するオーケストレータの優れた例で、分岐やエラー処理のルーティングを備えています。イベントレートは、イベントを生成、消費することでアプリケーションのさまざまな部分を振り付け、分散アプリケーションと連携させるのに適しています。マイクロサービス内のステップ関数と、3つの異なるマイクロサービスにまたがるマイクロサービス内のイベントレンジを考えてみてください。そして、これらのサービス内でも、コードを減らし、より効率的にする方法があります。ステップファンクションには、AWS SDKが統合されています。これは、任意のSDKアクションを呼び出すことができることを意味し、それはラムダ関数を取得して、ステップ関数から直接何かである。イベントブレイクツールにはAPIデスティネーションがあり、ウェブページから直接APIやインターネットを呼び出すことができます。セキュリティやリトライ、スロットリングが組み込まれているので、サービスを直接統合してラムダのカスタムコードを減らすための2つの方法です。さらに最近、Functionsはintrinsic functionsと呼ばれるものを発表しました。JSONの操作や文字列の操作など、小さなラムダ関数がありますが、この関数を使えば、ワークフローを構築する際に、コードやメンテナンスの手間を省くことができます。ゼロから始める必要はないのです。私たちのチームや多くの人がこのサービス・ワークフロー・コレクションをまとめました。これらは、必要に応じてアプリに追加したり変更したりできる、表面レベルのコマンドであらかじめ作られたオープンソースのステップ関数ワークフローです。もちろん、最も性能が良く、最も安価なラムダ関数は、1年後に削除され、内蔵の統合に置き換えられていることを忘れないでください。だから、確かにネイティブのサービス統合を使用してフルサービス、あなたが変換するラムダを使用する必要がないときにコーディングを避けるだけでなく、トランプ輸送とサービス間の通信に様々なメッセージングサービスを使用して、あなたは少数のより安全な単一の使用ラムダ関数とあなたが必要なだけ多くのサービスを使用して、ちょうど別のキーワード別のビット撤退を加えることは困難ではありません。あなたのワークフローオーケストレーションのためのステップ関数は、任意の機能を使用して、イベントブリッジは、振り付けとイベントのルーティングを処理しないことを意味します。しかし、ラムダは多くのサーバーレスアプリケーションにおいて、ビジネスロジックを実行するための超重要な部分であり、ちょっとした実用的なビジネスも頻繁に行われ、理解し探求する価値のあるサービスとしての素晴らしい能力を持っているのです。ラムダフェスティバルには2つの呼び出しモデルがあります。同期呼び出しでは、呼び出し側がCLIやSDKで直接ラムダを呼び出すか、関数URLの使用やギャグのようなサービスを通じてラムダを呼び出します。

初期化で関数を実行するには、これはハンドラの外にある関数内のコードです。コールドスタートと呼ばれる初期化フェーズが完了すると、次にインヴォークフェーズが行われ、ペイロードを受け取ってビジネスロジックを実行するハンドラコードが実行されます。そして、インヴォークが完了すると、実行環境は実際にハンドラプロセスを再び実行できる状態になり、これはウォームスタートと呼ばれます。そして、それは実際に重要な最適化、AWSが処理する部分とあなたのコードの部分と標準的な関数構成の一種で、その行はちょうど事前ハッカーコバーンの前ですの分離です。しかし、ラムダ自体の動作の一部を制御するための実行時修正に注目するような機能の過激なラボも可能です。つまり、最適化がほんの少し左側にシフトして、拡張コードやランタイムの折り畳み方をコントロールできるタイムラインになっているわけです。ご存知のように、新しいイベントを処理するためのランドスケープでコールドサンドが発生したり、より大きなプロビジョニングコンカレンシーが発生したり、機能コードや設定を更新したときに常にスタートと呼ばれる動作が発生したりすることもあります。そして、これらのアクションは、彼らが行うことを選択します。しかし、パルスオックスを作ることはありませんまた、時々、頻繁にではなく、あなたのためにサービスを管理するラムダの一部として発生します。我々は、他のは、それらを新鮮に保つために実行環境をリフレッシュすることができます維持する必要があります。また、故障したリソースを交換する必要がある場合、あるいはアベイラビリティゾーン間でリクエストをリバランスする必要がある場合、などです。高可用性の管理も代行したい。そして、これらは起こらないのです。これらはStartupと呼ばれるもので、実際に発生するものですが、コントロールすることはできません。これはサービスを管理するlambdaの一部に過ぎないのです。コードの起動時間は、100ミリ秒以下から数秒まで様々です。興味深いのは、コールドスタートに占める定数の割合が1%未満と非常に小さいことです。lambdaのメトリクスを見てみましょう。さて、開発者がアプリケーションを構築し、テストし、デプロイごとに構築する場合、デプロイごとにコールドスタートが発生することになります。医療用標準の特許出願中ですが、これは異常なことです。本番ではとんでもないことになりそうです。実際のところ、スケールアップしたときにどうなるかはわかりません。リクエストが多ければ多いほど、実行環境も多くなり、1回の起動が多くなります。そのため、コールドスタートの割合が減ります。また、VPCに接続するラムダ関数に対して低減された開始と呼ばれる、私たちは変更を行い、2019年だったと思います。だから、EPCにファンクションをつないでいれば、コンソールのペナルティは全くありません。しかし、コールドスタートのミシモト部分は、ハンドラの前に実行するあらゆるコードにあるので、これは、例えば、SDKsソフトウェア、ライブラリ、政府機密、多分データベース接続の確立、これらは通常投票の前に行い、その後の呼び出しにライブラリや接続を使用できるようにするコードである。しかし、これを最適化するために何ができるのか、そしてどんなベストプラクティスが考えられるでしょうか。さて、あなたがそれを意味しない場合、すべての骨抜きのロードの最初の、最適化された依存関係は、彼らが実行されるコードの量と展開パッケージのサイズを減らすためにできる唯一のバンドルです。それはまた、私が以前に述べたように、小さなpostererscopeラムダ関数を持つことができる場合、定数の進行をスピードアップするので、呼び出すものの束を構築しないことは、実際にあなたもネット生活を行うことができ、私はすぐにそれを紹介しますの複数の機能を行うために共有ライブラリの初期化を意味するものではありません。と事前関数同棲コードは、接続を確立するための大きなものですが、また、その後、さらに事前に再接続が死ぬために起こっているこれらの接続を取得するために準備される。HTTP接続の場合は、SDKとしてkeepaliveを使用すると、より接続性が向上します。それから、実行環境のライフサイクルを考えて、状態を保存して再利用することも考えてください。それについて考えてみてください。そして、私はスペイン語のコラムで、関数から始めることにしています。一つは、プロビジョニングの並行処理で、一つは、Javaのための超素晴らしいです。昨夜、我々はラムダスナップスタートを発表した文字通りJava標準のJavaのコムは、問題を解決するために開始します。それはクールではないでしょうか？ということで、依存関係を最適化するための情報をいくつか紹介します。

必要なものだけを使うということです。

この例では、いくつかのテストを実行します。あなたはDynamoDB SDKを使用する必要がある場合は、全体のAWS SDKの代わりに、特定のパッケージを持っていることが含まれ、最大125ミリ秒速くすることができます。同様に、X線とDashのコードとパッケージ名のパラメータとst 5ミリ秒を必要とし、X線の場合には、メソッドを切り替え、ドキュメントの時間参照ではなく、提供し、それは114ミリ秒高速化されました。つまり、より具体的であることは、コードがより小さなパッケージを参照し、コールドスタート時の初期化がより速くなることを意味します。また、バージョン2を目指すよりも、ノードバージョン3のSDKを使うことを考えましょう。そして今、これは実際にラムダ管理ランタイムの最近のコミュニティリリースノートからデフォルトで、これはあなたが実際に必要なパッケージをインポートする必要があることを意味します、それは異なるモジュールにあります。また、デフォルトでTCPコネクションユーズと呼ばれるようになり、コネクションのスピードアップに貢献しています。他にも便利な追加機能がたくさんあるので、見てみる価値はあると思います。今、それは非常に厳格なスイッチオーバーにあるので、あなたはそれを活用するためのいくつかの隠蔽を行う必要があります。だから、80を知るために移動するときは、このことについて考えてください。その場ですぐにアップグレードできるわけではありません。2月の遅延初期化とは、1つの関数の中に複数のハンドラがある場合のことで、パイプラインの例を見てみましょう。まず、下の3つのモジュールをインポートし、s3とDynamoDB DynamoDBクライアントから2つのグローバル変数を設定し、s3にオブジェクトの値の変数を取得し、s3にチェック、テーブル上で初期化、初期化し、DynamoDBにも同じことをするように実行しています。そして、初期化の段階で両方を持つのではなく、これは個々の呼び出しをより責任あるものにし、より応答性を高め、複数の関数にわたってグローバルなオブジェクトを形成することができます。しかし、もしあなたが私の呼び出しをスタートやプロビジョニング凹、またはSNAPスタートに最適化しても、これは彼の助けにはならないでしょう。今見ておくべき最適化は、これらのAWSのビルドプロセスにGravitonにARMベースであなたの関数を実行すると、x86アーキテクチャに比べて最大34％優れた価格と性能を得ることができます。特にNodeやPython、一部のJavaのようなインタプリタ型言語やコンパイルされたバイトコード型言語では、アーキテクチャを変更するだけで、何も変更することなく実行することができます。しかし、コンパイルされた言語は、ARM 64用に再コンパイルする必要があります。また、コンテナイメージを使用していない場合は、ARM用に特別にビルドする必要があります。現在、ほとんどのAWSツールは、grunt on tinでのガイダンスを透過的にサポートするSDKを提供しています。だから私はそれを試してみることをお勧めします。ラムダは、メモリが関数のパワーレバーである方法であることを理解する必要があります。これはあなたがコントロールする唯一のパフォーマンス構成で、128日から10ギガまでのすべての方法を1分単位で制御し、支出を増やすことができますし、AWSは関数に割り当てられた仮想CPUとネットワーク帯域幅の数を比例して増やします。つまり、メモリやCPU、ニコ動に制約されているコードでは、メモリを追加することで、パフォーマンスを向上させ、コストを削減することができるのです。メモリサイズが大きいと、設定できるメモリの量によりますが、比例して6つの購入ニュースに変換され、あなたも土地を使ってかなり大きなメモリとCPU集約型のワークロードを実行することができます。今すぐにも複数のコアのCPUバインドのワークロードを与えるメモリアロケータと任意のラムダ関数。もちろん、それを使うにはマルチスレッドである必要があります。ビジネスロジックにバッチ処理とメモリ割り当てを行い、スポットメモリ割り当てを行うことを検討する必要があります。ここで、100万以下のすべての素数を1000回計算する関数の結果をお見せしましょう。確かに、頭の中で計算するようなことではありません。そこで、128メガから1ギガの間でいくつかのメモリ構成を試してみました。そして、時間や秒数の点で、最もパフォーマンスの良い構成と悪い構成を見ることができました。コスト面でもそうです。最も性能の良いものと最も性能の悪いものの時間差は

10秒以上の差があります。

しかし、より高速な関数を実行した場合の追加コストは、わずか数セントです。つまり、時間的には劇的に速くなるのに、追加コストはほとんどかからないので、ワークロードには超便利かもしれません。それは自動的に構成がスーパー製品のマニュアルプロセスのビットすることができます古い取得します。ラムダパワーの2大オープンソースツールは、データ駆動型のアプローチで、ラムダ関数のあらゆるパワー構成を視覚化し、微調整するのに役立ちます。実際、このツールは、ステップ関数ステートマシンを使って、異なるメモリ構成で複数のバージョンの関数を同時に実行し、それらのパフォーマンスを測定します。そして、実際の関数呼び出しを実行するあなたのアカウントで実行されるため、実際のコストと速度が表示され、すべての自動化された方法の適切なバランスを見つけることができます。さらに、CI CDパイプラインに接続して関数を自動解析し、その2つの関数をグラフィカルに比較することもできます。また、Gravitonへの移行を検討する際にも、両アーキテクチャのコストを別々に計算することができるので、比較することが可能です。例えば、このarm関数は、x86版に比べて27％高速で、41％安価です。この機能は、実際のワークロードに対して適切なメモリ構成を提供する、非常に有用なツールです。さて、DPCについてお話しました。しかし、よく受ける質問は、実際に自分の関数をMVCに接続しに行かなくていいのでしょうか、というものです。では、どのような場合に必要なのでしょうか？まあ、VPC内に関数がアクセスする必要のあるリソースがある場合、lambdaはPC easy Connectに接続されています。ラムダ関数は、ラムダサービスVPCで実行し続け、その後、彼らは実際にリソースを開始することができますあなた自身のV PCにラムダによって接続されています。そして、この設定は、関数のCreateにあります。ですから、先ほども言ったように、コールドスタート時間には影響しないのです。しかし、必ずしも関数をVPCに接続してセキュアにする必要はありません。なぜなら、すべてのAWS内部トラフィックは、アプリとしてグローバルバックボーンを使用し、それがいわばオープンインターネット上で実行されていないだけであるようにするために暗号化されています。しかし、追加のネットワーク、ルーティング制御、または出口アクセス制御のようなものが必要な場合、あるいはVPCフローログでより多くの可視性が必要な場合、このためにVPC機能を使用することも可能です。そして、もしラムダを使いたいのなら、ラムダは様々な部分で素晴らしい働きをする。しかし、先ほどラムダのライフサイクルを見ていたので、同時実行性の話に切り替わります。並行処理とは、関数が一度に処理するリクエストの数のことです。同時処理とは、同時に処理できるリクエストの数のことです。成熟した関数は、イベントを処理する実行環境としてラムダのインスタンスを呼び出し、どのように呼び出されたかにかかわらず、一度にひとつのイベントを処理します。バッチを使うサービスを利用している場合、あるいはサービスから引き出されたバッチには複数のアイテムが含まれていることがありますが、それは1つのイベント1つのイベントとみなされます。つまり、タイムラインは左から右へと進み、1つのリクエストが来て、ラムダが初期化コードを実行し、関数を呼び出すという流れになります。

そして、その関数は一度に一つのリクエストしか処理できないので

のため、実行環境はブロックされます。この時のために 再び関数が呼び出されると、1つのリクエストがプロセスに格納され、関数の並行性を高めた別の実行環境別のインスタンスが用意される。そして、関数コードの実行が終了すると、別のリクエストを処理できるようになります。そしてここで、リクエスト1が完了したことがわかります。これは、先ほど見たような null and free ではありません。そして、このプロセスは継続され、後続のプロジェクトでは、実行環境があればそれを再利用し、並行性を高める必要があれば新しい実行環境を作成することになります。並行処理とは、同時に発生する要求や入力の数のことである。1つの実行環境では、同時リクエストの数

は常に1つになります。

そして、この図では、前の図のように対処して、実行環境の数と同じ数の同時実行が起き始めると、どのように変動するかがわかります。そして、個々の関数については、作品同時実行数メソッドを使って同時実行を行うことができます。それはどのように並行処理と秒あたりのトランザクションに関係するのでしょうか？ラムダが1秒間に処理できるトランザクションの数は、その時間内に呼び出されたすべてのトランザクションの合計です。だから、関数は、1秒のサーバーを取り、10ボートは10実行環境を作成する必要がある明らかに法律を持って、この場合、ラムダは毎秒10の要求を処理するつもりです。しかし、関数の持続時間は、2番目の半分でそれらを見つけるのは難しい場合、ラムダパラメータは、残りの10はまだ10実行環境クレジット処理要求になるだろう、しかし、彼らは1秒以内に再利用されようとしている秒あたりのトランザクションは、現在撮影される予定です。また、最大関数と要求の最大数を割り当てるために予備コンカレンシーを使用することができますこの関数として、合計クォータから特定の関数を満たすから自分の通貨を参照してください実際に重要な保護と関数が常に予備通貨値までスケールアップすることができることを確認し、追加のユースケースを処理するためことができます。さらに、下流のリソースを保護するために、最大機能通貨を設定または制限することができます。つまり、外部API用のデータベースが最大50の接続しか処理できない場合、同時入力が50を超えて下流のサービスに負担がかからないようにすることができます。そして、もしそれがゼロに見えたら、面白いことに、すべてのバグを止めることができます。そして、この問題は、あなたが何かセキュリティサービスソフトウェアのバグを持っている場合、それはあなたに再びダイヤルアップする前に問題を解決するためにいくつかの時間を与えることができます。コントロールは、通貨に関する規定で、公開された関数のバージョンに対して、利用可能な実行環境の最小数を設定することができます。

公開された関数のバージョンで使用可能な実行環境の最小数を設定することができます。

効果は、事前にウォームアップ機能によって、コールドスタート処理を実行していることを確認しましょう。そして、これは主に同期的なリクエストに有効です。トラフィックの急増が予想される前に、十分なラムダ環境を確保しておきたいのです。例えば、午前8時に設定されていなかったり、午後9時にストリーミングするようにテレビで表示されていたりするわけです。また、標準的な包括的デプロイメントを使用すれば、特定の状況下でコストを削減することも可能です。そして、この2つの同時実行のポインターを覚えておいてください。バーストコンカレンシーのクォータは、1分あたり503,500インスタンスの間で、各機能の初期バーストトラフィックを提供します。また、アカウント同時実行数のクォータもあります。これは、特定のリージョンで入力できる最大同時実行数です。これは実際には、その地域のアカウント内のすべての機能で共有されます。そして、このデフォルトの1000は、実験室では簡単にとんでもないレベルまで参照される可能性があります。ですから、この値がどの程度になるかは心配しないでください。さて、リザーブ通貨も覚えておいてください。これは基軸通貨を取得するためのプールで、まだ話は続きますが、その様子を見てみましょう。これが、私たちが考えるアプリケーションの例です。負荷の増大を見越して、アプリケーションのソースは合計で27,000ドルを調達しています。午前9時前 ご覧のように アプリケーションは1000の同時実行環境を使い リクエストの安定したストリームを持っています。各ラムダはミリ秒かかります アドナン・アルは持続的な場所の細胞によってトラフィックの大きなスパイクを持っていると言う。さて、1000の場所は、既存の実行環境を使用しています。それは実際に16000まで、毎秒すべての5000要求トランザクションを処理するために十分な最初の同時実行ではなかったので、その後、地区1000リクエストを処理するために新しい環境を作成するために3000利用可能なバースト並行輸入の使用は、しかし整然とした。来月開始する追加のバスケット通貨繊維の要求から分あたり別の50万票からレモンチェロは、別の500によってスケールアップするつもりです 時間リモートリクエストはスロットルされようとしている。アプリケーションは5000件のリクエストすべてを処理することはできません。そして、アプリはサステイン5000リクエストを処理し続け、誕生は500にデバイスを引用するようになる可能性があります最初のコンポーネントは、青い線は、大きなドットを参照してください。今回明らかになった絶対無効のスパイクから4分経過した時点で、予想外の3000件の使用持続要求が到着し、合計8000件になります。5000リクエストは既存の実行環境を使用し、ラムダは1000リクエスト以上を処理するために、1000の無効またはバースト同時実行を使用して、新しい実行環境を作成するとき、我々は別の1000リクエストに達すると同時実行数の制限と同時実行数クォータに達しているとしてスロットルの両方を持っているかについて話をします。今、それらのどれも後でラムダは別の基本的な基本によってスケールすることができます。最初のコンポーネントは、この500ページ数の貢献ポリシーのクォータは、まだ4000リクエストを投げるつもりです。500のリクエストが処理されると言ったところで、1000のリクエストはまだ話し中です。これらの1000のリクエストはまだ同時実行から話すつもりです。このように、アプリケーションは7000のリクエストを維持し続けることになりますが、アカウントの同時実行性があるため、1000は問題ないはずです。しかし、もちろん、これは非常に簡単に上げることができ、その後、アプリケーションはそれらの要求を処理することができるようになります。つまり7分間で、この機能は1秒あたり約4000のトランザクションから28000のトランザクションまでスキャンすることになるのです。このように、実行環境の再利用を実現するためには、様々な呼び出しモデルやラムダライフサイクルの仕組みについて、時間をかけて理解することがとても重要です。この記事では、コールドスタートの最適化に関する有用なヒントをいくつか紹介し、コストを節約してより多くのパフォーマンス要件を満たす方法と、ラムダ関数を通じてパワーレバーとしてメモリメモリを使用し、最適化のためにCPUとネットワークとメモリの場所を追加する方法、そしてVPCへの接続関数について深く掘り下げ、そのコードはラムダの拡張に有効であることがわかります。次は、色としてのコンフィギュレーションについてお話したいと思います。これは、サービスアプリケーションを開発・デプロイする際に、インフラストラクチャのコードを使うことで、スーパーパワーを手に入れることができるというものです。インフラストラクチャ・コードとは、クラウド・リソースを定義してソース・アプリカード・アプリケーション・リソースをカバーし、設定ファイルを使ってインフラストラクチャをセットアップできるようにすることで、実質的に設定ファイルをソフトウェア・コードのように扱うことができるようになります。また、バージョン管理、レビュー、プルリクエストなど、ソフトウェアとはまったく異なる方法で、プロビジョニングプロセスを自動化し、堅牢で再現性の高いデプロイメントを実現することも可能です。設定を削除しても、複数の環境やアカウントにデプロイすることはできないので、さまざまな面で役に立ちます。今、サービスや特定のインフラ、コードツールを探して、AWSのクラウドリソースを定義するために、私たちはSam book source frameworkとCDKを持っています。また、オープンソースで、使い慣れたプログラミング言語を使って、難しいソースを見つけることができます。さてブックエクスパンダー、シンタックス、インテリジェントネイション。また、本当に素晴らしいサードパーティツールも数多くあります。もしあなたがそれらを使っているなら、彼らは本当にあなたがカウンセリングのフレームワークから始める習慣を取り除き、新鮮なアプローチを使いたいと思うかもしれません。では、どうすれば可愛いリスのマスコットに関心を持つことができるのでしょうか。ということで、2つのパーツに分かれています。設定ファイルを元にCloudFormationを生成するtransformコンポーネントです。そして画面右側には、パッケージング・デプロイによるボーカルやキャリバーインタビューを支援するツールが一通り揃っているのです。例えば、たった20行のコードで、連携したリソースの束を生成することができるわけです。SAMテンプレートテンプレートは、APIゲートウェイエンドポイントを生成し、関連する役割を持つテーブルから関数または3つを学ぶためにそれを接続するつもりです。さて、これらのリソースをすべて生成するのは涼しい時間ですが、ロックするものすべてにセキュリティのベストプラクティスを組み込むことができることも確認したいものです。もちろん、これは簡単なオプションです。誰もやったことがないのでしょうか？スターにリソースにアクセスする権限を与えて、物事を動かすだけですが、それは本当に悪い習慣なのでしょうか？しかし、これは本当に悪い習慣です。Iam access analyzerは、100以上のポリシーチェックとセキュリティ警告を提供するもので、同じようにポリシーを検証することができます。しかし、Samはまた、いくつかの

非常に便利で使いやすいビルトインポリシーがあります。

しかし、Samには、ラムダ関数を構築する際に、そのパーミッションをスコープするための、非常に使いやすいビルトインポリシーがあります。だから、私はDynamoに向かってラムダ関数で示した前のテクニックが、唯一の3つのダンス。そのため、手動でイオン全体のポリシーを作成する代わりに、DynamoDB、読み取りポリシーを追加し、テンプレート内の特定のテーブルを参照して、必要なスコープとポリシーを設定するだけでよいのです。そして、75以上の利用可能なポリシーテンプレートがあり、膨大な数のサービスをカバーしています。特定のポリシーテンプレートと対話するための機能メニューを学ぶことで、アプリケーションをより安全にするための適切な特権的パーミッションの使用がより簡単になります。しかし、何か最近サムコネクタも出てきました。これもCloudFormationのリソース同士を繋げるためのものです。ソースとデスティネーションを追加し、読み取り権限か書き込み権限かを追加するだけで、Samがすべて把握してくれるので、特にロシュナガー機能のリソース同士を接続するときに便利です。だから、接続のどちら側でパーミッションが必要かを覚えておく必要はありません。私は時々、ハードカバネスがあなたの命名に追加される方法についてのクイックサイドの便利なテンプレートみたいなものがあることを知っているので、再利用がずっと簡単になりますし、コマンドラインから直接オーディオリソースにできるサウンド削除を使うことも忘れてはいけません。サウンドも計算から分岐し、hashey Corp TerraFormを使ったローカルテスト用のプレビューがあります。そして、多くのお客様がTerraFormを使用しているので、これは後にサムとハッシュを作るための旅の最初のステップです。一緒に。また、新しい完全なSamのワークショップへの偉大なは、サービス開発のライフサイクルの多くを介して、Samがどのように役立つかについて説明します。今日はSamについて多くの時間を割いて話していますね。また、他のサードパーティツールも非常に便利で、中にはその機能の大部分を実現できるものもあります。フレームワークを使ってサービスアプリケーションを構築する場合、実はゼロから始める必要はないんです。サービスパターン集は、サービス統合のための多くの言語とサービスにわたる400以上のSam CDKとTerraFormのコードパターンを余地のないリソースである。だから、APIゲートウェイを使用してそれを構築し、ラムダは、そのための既存の特許を持っている、またはそのための複数のおそらく不完全な用語、ヴィンテージはすでに既存の特許としてそれに名前を付ける誰として使用することができます、あなたはコピー＆ペーストして自分のアプリケーションを使って、またはあなたのそれはオープンソースだとあなたの羽の表面ビルダーを助けるために送信することができます。だから、人生を変える構成を使用するときは、フレームワークを使用してコードです。これは、プログラム的にレポのインフラストラクチャとストレージのテンプレートを作成し、それを使用できるようにすることができるという超大国の数を提供します。セキュリティポリシーテンプレートとサウンドコネクタを確保し、パターン集ですぐに始められるようにします。次のセクションでは、プロトタイプから製品化までのソフトウェア開発ライフサイクルについて説明します。さて、従来の開発ワークフローは、ローカルマシン上で行われ、コードをコミットする前に、次のようなワークフローを提供します。コードのテストは、コードを実行してその結果をチェックするものです。これはインナーループと呼ばれ、高速なフィードバックとアプリケーションの開発を可能にします。さて、今日、開発者はしばしば、彼らは新しいライフサイクルで全体のアプリHerculeanタスクを実行する必要があると思うように。しかし、あなたがアカウントリソースを構築するとき、他のサービスとの統合がたくさんあるため、主に行うようになったことを示している、他のAPIに接続するイベントを送信するメッセージを送信します。データベースと会話し、どのように物事をテストすることができるかにあります。しかし、開発者にとってより重要なのは、素早くテストすることではなく、実際にローカルでテストすることなのです。ローカルでテストできるように、ラップトップで他のすべてのサービスをエミュレートしようとする誘惑に駆られるかもしれません。しかし、これは難しい。最新かつ最高の機能をサポートするために使用するすべてのサービスのモックやエミュレータを持っていないかもしれません。そうすると、コードを管理している間に、エミュレータの管理に多くの時間を費やすことになります。ですから、できる限りこれを避けるようにしましょう。しかし、機能的なWebアプリケーションを構築するのであれば、他のエミュレータを検討する価値がありますし、クラウドアーキテクチャはその点で実に優れた働きをします。サポートフレームワークや複雑なロジックの使用は控えめに、ペイロードは絶対に避けてください。ビジネスロジックを提供し、機能をテストすることができます。このように、政治とクラウドの両方の長所を生かしたいのです。ビジネス・ロジックを実行するコードを、できるだけ早く実際のクラウド環境でローカルに反復できるようにしたいのです。APIゲートウェイのラムダをローカルで素早くテストし、何かを実行するときにはクラウド上の他のサービスと通信することができます。クラウド上で統合テストを実行できるので、セキュリティのようなものをごまかす必要がなく、より正確なテストが可能になります。さて、以前は良いアイデアで、最も簡単に使えるように聞こえました。だから、再び、同じチームは正義を修正するために衛生的に出てきた。3つの主要なコンポーネントが集まっているので、可能なコードベースを構築するだけのビルドで、最初は6〜10日で多くの差分サンシンフォニーを子機に変更しました。そして、残りのインフラをクラウドに展開し、ユニットテストや機能的なKetopia APIに反復することができます。変更する必要があります。だから、あなたのローカルテンプレートファイルやファイルのコードであり、唯一の同期的な変更を再構築する必要があり、それははるかに高速化？

あなたのコードを保存したとき？

バックグラウンドで、迅速に中央のコードは、チャネルに変更し、それははるかに高速化されません。サウンドモードもこのサービスの一部で、複数のログストリームやトレースから集約されたフィードバックが得られ、ローカルとチャンネルの両方のリソースを使ったインナーループを本当にスピードアップできます。このように、クラウドでのサービス・アプリケーションの開発方法を変えることで、ローカルでの高速な開発体験と、実際のチャレンジングなリソースの使用という、両方の長所を得ることができるのです。確かに、私のデフォルトのサーバー構築方法は、見てみることをお勧めします。さて、私がインフラストラクチャのコードテンプレートを作成する際、本当にやりたいことは、このテンプレートを再利用可能にすることです。開発者に自分のアカウントを与えることで、開発者が探索したり、ビルドしたり、前回はMRをビルドするためのサンドボックスを所有しました。他にも複数の環境があります。ステージング・プロダクションは本当に自分のアカウントを持つべきです。ワークロードを分離することで、より多くの目的やリースのために、より良いセキュリティが得られます。とにかく、彼はそうしたと思います。そして、クォータや制限をコントロールし、本番データとgdPIを保護することができるのです。テンプレートは、環境間でテンプレートを再利用することで、デプロイメント全体の一貫性を保つことができ、さらに大きな力を発揮します。また、設定ファイルをパラメータストアのようなものに効果的に外部保存し、他のテンプレートを参照することで一貫性を確保することができます。しかし、これらのアカウントを管理するだけではなく、もっと大きな視点で考える必要があります。データベース組織は、先ほどお話した病原体が自分のアカウントに来るように去勢するのに役立つと思います。しかし、複数のアカウントを持つことができない場合もありますし、開発者が共有アカウントと以前のプレフィックスリソースをキャンセルして簡単に展開できるようにするための準備が整っていない場合もあり、アカウント内またはアカウント間でのリソース共有ができないこともあります。そして、これはより高価なサービスやセットアップが困難なものには最適です。つまり、すべてを別々にする必要はないのです。今日、実はかなり現実的なことができるのです。また、インフラストラクチャ・コードのもう一つの強みは、CI CDパイプラインをより自動化することで、再利用可能なテンプレートとしてソフトウェアを自動的にデプロイし、プロセス中に繰り返し使用できるようにすることです。統合テストにより、パイプラインの自動化が進みます。

そしてデプロイメントモニタリング。

今、多くの開発者は、巨大で複雑なデリバリー・パイプラインで、自分たちがサービスできないようなものに押し上げてしまっています。本番稼動させるためには、パイプラインがすべてを処理しなければならないのです。しかし、より小さな個別のコンポーネントや関数で構成されるサービスであれば、再利用可能なテンプレートを使って、複数の新しいパイプラインをより速く構築することができます。機能ごとに、あるいはコミットごとに、本当にユニークなリリースパイプラインを作ることができるのです。SamにはSam pipelinesという機能があり、コードから複数のアカウントにアーティファクトをデプロイするための信じられないようなリソースパーミッションがあり、設定ファイルやコードパイプライン、GitLabやGitHubアクション、Jenkinsなどを生成する機能が備わっています。あなたが見る、あなたはそれを使用することができるように取り残されたと感じる必要はありませんコンストラクトLaravelはコードパイプラインを使用してCI CI CDパイプラインを設定するので、一度生産に結婚物事を押し、ここで生産と観測性駆動開発でテストを包含について考えるいくつかのクールなアイデアを持っていることができます。コードがこのユニットテストと検証を通過したら、トラフィックのサブセットにデプロイして、前のバージョンと比較してどうなのかを確認することができます。これによって、本番環境で安全に実験を行うことができるのです。そして、監督者である観測可能性の賢人Chaturbateは、本番でテストをしないのは、自分のソロが家でうまく聞こえるからといって、フルオーケストラで練習をしないようなものだと言っています。しかし，観測可能性を重視した開発は，コードのライフサイクル全体とビジネスの使いやすさについてです。ソフトウェア開発ライフサイクルの早い段階で観測可能性を含めることで，サービスがどのように正しいか，そして最も重要なのは，変更がビジネスに及ぼす影響についての質問に答えることができます。特に、サービスやイベント駆動型アーキテクチャでは、優れた観測性が超重要です。テストとプロダクションのために、機能フラグとトグルについて考えるのはクールなことです。ソースコード上で複数の機能ブランチを維持する代わりに、コード内で条件を使用することができます。コード内の条件を使って、実行時にオンデマンドで機能を有効にしたり無効にしたりすることができます。これは、あなたがたまたまそれをデフォルトにするまで、その後に使用するために機能をより多くオンにしているのです。これは、リリースと運用をよりシンプルにします。AVテスト、特にテストとプロダクションの機能フラグ Canaryテストは、ビデオのためのそれらのガードレールを設定するための素晴らしい方法です。おそらくこれはあまり使うべきではありませんが、私たちはAWSの内部でカナリアを多く使っており、合成を支援するツールです。コールバックとメトリクス形式を使用して、顧客が観測可能なチケットになる前に機能を試行錯誤しているときに問題を発見するのに役立ちます。これは、ログエントリから非同期ポスターまで自動的にメトリクスを作成して、より速く、より安く、多くの有用性を高める強力な機能です。左側には、イベントのペイロードを削除します。左側から、埋め込みメトリクスフォーマットを使用して、このために生成されたログエントリを見ることができます、関数、呼び出し、および他の種類のものに関するすべての情報は、自動的に挑戦メトリックにエクスポートされます。ですから、自分でメトリクスを構築するために、それらを渡すためのプロセス全体を構築する必要はありません。Python、Java、C Sharpなどのオープンソースのクライアントライブラリもありますので、構造化ログの力を一度使ってみる価値はあると思います。構造化ログを作成したら、さらにできることがあります。Log insightは、クラウドウォッチ用のインタラクティブなログ分析機能です。この機能により、構造化ログに含まれるあらゆるデータ（メトリクスなど）を基に、クエリーを生成してデータを検索し、可視化することができます。ここにある例は、その領域を示すための簡単なものです。しかし、他にもさまざまなものを作成することができます。また、余った土地のスニペット・コレクションにリンクされていて、最も高価なエモートを見つけたり、投票サイトを追跡したりといった、ラムダ特有の便利な洞察の例をお気に入りに入れておくことができるようになっています。観測可能性と他の機能を持つ重い荷物を移動するためのツールの便利なセットではありません私はAWSとコミュニティが作成したこのオープンソースの気候Palatinesを愛しています。Missでは、より簡単にラムダ関数にロギング、トレース、メトリクスを追加することができ、また、ライブラリをコードにインポートするだけで、有用な追加ユーティリティが追加され、さらにレイヤーレイヤーも追加されます。このレイヤーには、現在利用可能なPython、Java、Typescript、dotnet用のエンコードするための2つのコンパイラと、以前のレイヤーがあります。

を見てみてください。また、ユースケースを拡張し続けることもできます。サービス・アプリケーションの可観測性をマスターする」という8つの学習パートからなるビデオ・シリーズには、さらに多くのサービス・オブザバビリティに関する情報が掲載されています。ぜひご覧ください。また、新しい観察可能性ワークショップもあります。これは実践的で、観察可能性のトピックを一通り学びますが、それらは必ずしもサービスと他の種類のものとの関連だけではありません。Palioのエリートは、複雑なシミュレーションを避けることで、クラウドの力を借りてローカルで素早く開発・テストすることができます。インフラストラクチャのコードを使用することで、再利用可能な技術、分離された照明スタック、ICDパイプライン、構造化されたロギングとパワー、ログから簡単にメトリクスを取得することができます。そして、忘れてはいけないのが、ログの保存の設定です。これは、不要なものを保存しないように、テンプレートで設定するのが最適です。

お金を節約するためです。そして、ラムダ・パワー・ツールも見てください。ここには、より簡単にするための機能がたくさんあります。そこで私は、サービスを考え方や運用の構成要素として捉え、サービスや感情、勝利のインフラストラクチャの力を使って、コンテンツの状態にイベントの力を活用する方法を支援するようになりました。アーティストの皆さん、私は旅をしながら、多くのことをカバーすると言ってきました。大丈夫ですか？仕事中にちょっとつぶやいてしまいましたが、なんとかやっています。しかし、その場合でも、私はおそらく、すべての最高のリソースと最適化を与えることができる可能性があります。リンクを見てください資源ページ私はつもりだにいくつかのより多くのものを追加します。このページには、一般的なサービスのベストプラクティスや今日の学習について、さらに多くの情報が掲載されています。だから、新しいサービスの学習を継続するために、自分のペースで学ぶために多くの情報を見つけるためにQRコードを使用して、あなたの知識を増やし、あなたがさらにたくさんの一般的なサービスの情報を払っていることをこのバッジの上に気づくことができれば、多くのリソース、サーバー、UX、および贅沢についてのすべての昨年と余剰土地穏やかへ向かいます。私は本当にあなたが今日見て時間を割いて感謝し、私はあなたが専門家が使用し、あなたも同様に使用することができます何か有用なベストプラクティスを学ぶのを助けることができたことを願っています。より良いサービスを提供できるようになります。そして最後に、もしあなたが深く掘り下げた技術的なフォームレベルのコンテンツが好きなら、多分入れすぎかもしれませんが、素晴らしい情報ばかりなので、どうしたらいいか決められませんでした。そして、ちょっとした賄賂として、5つ星の評価セッションのアンケートで、あなたが技術的なコンテンツを気に入ってくれたことを知ることができます、本当にありがとうございます。今日からあなたも参加できますよ。夕方

書き起こし： https://otter.ai